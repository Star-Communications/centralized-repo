name: ci-push-image

on:
  workflow_call:
    secrets:
      AWS_ROLE_TO_ASSUME:
        description: "ARN of the AWS role to assume"
        required: true

    inputs:
      runs-on:
        description: "The type of runner(s) to use (comma separated)"
        type: string
        default: "ubuntu-latest"
        required: true

      api-project-name:
        description: "Name of the API project to download from S3"
        type: string
        required: false

      spa-project-name:
        description: "Name of the SPA project to download from S3"
        type: string
        required: false

      project-bundle-name:
        description: "Name of the project bundle"
        type: string
        required: true

# disable permissions for all scopes (except for id-token)
permissions:
  id-token: write

jobs:
  create-temp-folder:
    runs-on: ${{ inputs.runs-on }}

    steps:
      - name: Create or empty temporary folder
        run: |
          if (Test-Path -Path "TemporaryFolder") {
          Remove-Item -Path "TemporaryFolder" -Force -Recurse -ErrorAction SilentlyContinue
          }
          New-Item -ItemType Directory -Force -Path "TemporaryFolder" | Out-Null
          echo "Temporary folder created or emptied."

  download-api-release:
    needs: create-temp-folder

    uses: ./.github/workflows/download-s3.yml
    if: ${{ inputs.api-project-name != '' }}
    with:
      runs-on: ${{ inputs.runs-on }}
      s3-bucket: sc-releases-bucket
      s3-prefix: ${{ inputs.api-project-name }}
      download-path: "./TemporaryFolder"
      # unzip-file: true
    secrets:
      AWS_ROLE_TO_ASSUME: ${{ secrets.AWS_ROLE_TO_ASSUME }}
    # the job returns the following outputs:
    #   downloaded-name-job-output:

  download-spa-release:
    needs: create-temp-folder

    uses: ./.github/workflows/download-s3.yml
    if: ${{ inputs.spa-project-name != '' }}
    with:
      runs-on: ${{ inputs.runs-on }}
      s3-bucket: sc-releases-bucket
      s3-prefix: ${{ inputs.spa-project-name }}
      download-path: "./TemporaryFolder"
      # unzip-file: true
    secrets:
      AWS_ROLE_TO_ASSUME: ${{ secrets.AWS_ROLE_TO_ASSUME }}
    # the job returns the following outputs:
    #   downloaded-name-job-output:

  process-and-organize-files:
    needs: [download-api-release, download-spa-release]
    runs-on: ${{ inputs.runs-on }}

    outputs:
      combined-version: ${{ steps.set-version.outputs.combined-version }}

    steps:
      - name: Extract version information from file names
        id: set-version
        run: |
          echo "Temporary folder contents:"
          ls -l ./TemporaryFolder
          cd ./TemporaryFolder
          echo "Current directory: $(pwd)"
          echo "API project name: ${{ inputs.api-project-name }}"
          echo "SPA project name: ${{ inputs.spa-project-name }}"
          $api_version = (Get-ChildItem facility-api-*.zip).Name -replace 'facility-api-(.*)\.zip', '$1'
          $cms_version = (Get-ChildItem facility-cms-*.zip).Name -replace 'facility-cms-(.*)\.zip', '$1'
          echo "API version: $api_version"
          echo "CMS version: $cms_version"
          # Set the combined version as an output variable
          $combined_version="api-$($api_version)+cms-$($cms_version)"
          echo "combined-version=$combined_version" >> $GITHUB_OUTPUT

      - name: Unzip API archive
        run: |
          Expand-Archive facility-api-*.zip -d facility-api

      - name: Unzip CMS archive
        run: |
          Expand-Archive facility-cms-*.zip -d facility-cms

      - name: Move CMS dist folder into API publish folder
        run: |
          mkdir -p facility-api/publish
          mv facility-cms/dist facility-api/publish/

      - name: Verify folder structure
        run: |
          tree facility-api

  # check-image-exists:
  #   needs: [download-api-release, download-spa-release]
  #   runs-on: ${{ inputs.runs-on }}

  #   outputs:
  #     image-exists: ${{ steps.check-image.outputs.image-exists }}

  #   steps:
  #     - name: Check if Docker image exists in GHCR
  #       id: check-image
  #       run: |
  #         $imageName = "${{ inputs.project-name }}:${{ needs.pre-deploy.outputs.latest-version }}"
  #         $imageExists = docker manifest inspect localhost:5000/${{ github.repository_owner }}/${imageName} > $null 2>&1
  #         echo "image-exists=$($imageExists -eq $true)" >> $env:GITHUB_OUTPUT

  build-and-push-image:
    needs: [process-and-organize-files]
    runs-on: ${{ inputs.runs-on }}

    steps:
      - name: Build Docker image
        run: |
          docker build -t localhost:5000/${{ inputs.project-bundle-name }}:${{ needs.process-and-organize-files.outputs.combined-version }} .

      - name: Push Docker image to local registry
        run: |
          docker push localhost:5000/${{ inputs.project-bundle-name }}:${{ needs.process-and-organize-files.outputs.combined-version }}

  clean-up:
    needs: [process-and-organize-files, build-and-push-image]
    runs-on: ${{ inputs.runs-on }}

    steps:
      - name: Clean up temporary folder
        run: |
          Remove-Item -Path "TemporaryFolder" -Force -Recurse -ErrorAction SilentlyContinue
          echo "Temporary folder cleaned up."
