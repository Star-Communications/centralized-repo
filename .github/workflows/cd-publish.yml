name: cd-publish

on:
  workflow_call:
    secrets:
      AWS_ACCESS_KEY_ID:
        description: "AWS access key ID"
        required: true
      AWS_SECRET_ACCESS_KEY:
        description: "AWS secret access key"
        required: true

    inputs:
      runs-on:
        description: "The type of runner(s) to use (comma separated)"
        type: string
        required: true

      target-version:
        description: "Version to deploy"
        type: string
        required: true

      windows-service-name:
        description: "Name of the Windows service to deploy"
        type: string
        required: true

      s3-release-bucket:
        description: "Name of the S3 bucket to download the release from"
        type: string
        required: true

      s3-prefix:
        description: "Name of the S3 bucket prefix (subfolder) to upload to"
        type: string
        required: true

      build-folder-name:
        description: "Name of the folder containing the build files (eg. 'publish' or 'dist')"
        type: string
        required: true

      env-file-name:
        description: "Name of the environment file (eg. 'appsettings.json', 'appsettings.prod.json' or '.env')"
        type: string
        required: true

env:
  # Path to the executable of Windows service to deploy
  SERVICE_ROOT_PATH: ""
  TARGET_RELEASE_S3_OBJECT: ""
  UNZIPPED_RELEASE_FOLDER: ""

# disable permissions for all of the available scopes
permissions: {}

jobs:
  deploy-publish:
    runs-on: ${{ inputs.runs-on }}

    steps:
      - name: Log runner label(s) & fail if 'ubuntu-latest'
        shell: pwsh
        run: |
          echo "runs-on: ${{ inputs.runs-on }}"
          if ('${{ inputs.runs-on }}' -eq 'ubuntu-latest') {
            echo "This workflow is not intended to run on ubuntu-latest. Please use self-hosted runner label(s)."
            exit 1
          }

      # ********** Get executable path of windows service **********
      - name: Set executable path of Agent windows service
        run: |
          $agentPath=$((Get-CimInstance -ClassName Win32_Service -Filter "Name='${{ inputs.windows-service-name }}'" | Select-Object -ExpandProperty PathName) | Split-Path -Parent | Split-Path -Parent)
          echo "agentPath - $agentPath"
          if ($agentPath) { echo "SERVICE_ROOT_PATH=$agentPath" >> $env:GITHUB_ENV }

      # ********** Download release folder from S3 **********
      - name: Configure AWS credentials
        id: configure-aws-credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-central-1

      - name: Get S3 object name of release "target-version"
        run: |
          $targetReleaseObj = @(aws s3api list-object-versions --bucket "${{ inputs.s3-release-bucket }}" --prefix "${{ inputs.s3-prefix }}" --query "reverse(sort_by(Versions[?contains(Key, '${{ inputs.target-version}}.zip')], &LastModified))[0].Key" --output text).replace("${{ inputs.s3-prefix }}/", "")
          echo "Target release object in S3: $targetReleaseObj"
          # throw an error if $targetReleaseObj IsNullOrWhiteSpace
          if ([string]::IsNullOrWhiteSpace($targetReleaseObj)) {
            throw "Target release version not found in S3. Invalid S3 object name."
          }
          echo "TARGET_RELEASE_S3_OBJECT=$targetReleaseObj" >> $env:GITHUB_ENV

      - name: Download release zip from S3
        shell: pwsh
        # download release zip from S3 (if it doesn't exist locally)
        run: if(!(Test-Path "${{ env.SERVICE_ROOT_PATH }}/releases/${{ env.TARGET_RELEASE_S3_OBJECT }}".replace("-latest", ""))
          { aws s3 cp "s3://${{ inputs.s3-release-bucket }}/${{ inputs.s3-prefix }}/${{ env.TARGET_RELEASE_S3_OBJECT }}" "${{ env.SERVICE_ROOT_PATH }}/releases/${{ env.TARGET_RELEASE_S3_OBJECT }}".replace("-latest", "") }

      # ********** Update windows serivce **********
      #   - name: Curl backup endpoint (to AgentApi)
      #     run: curl -X POST https://api.scout-camp.io/backup

      # Self-hosted runners requires elevated privileges to install and start services - cmd (as admin) run: "config "NAME_OF_YOUR_SERVICE" obj= "NT AUTHORITY\SYSTEM" type= own"
      - name: Stop Agent windows service
        run: if ((Get-Service "${{ inputs.windows-service-name }}").Status -eq "Running") { Stop-Service -Name "${{ inputs.windows-service-name }}" }

      - name: Unzip release zip
        run: |
          Expand-Archive -Path "${{ env.SERVICE_ROOT_PATH }}/releases/${{ env.TARGET_RELEASE_S3_OBJECT }}".replace("-latest", "") -DestinationPath "${{ env.SERVICE_ROOT_PATH }}" -Force
          $unzippedFolderName=${{ env.TARGET_RELEASE_S3_OBJECT }}.replace('-latest', '').replace('.zip', '')
          echo "UNZIPPED_RELEASE_FOLDER=$unzippedFolderName" >> "$env:GITHUB_ENV"

      - name: Overwrite new release build folder to existing build folder
        run: Copy-Item -Path "${{ env.SERVICE_ROOT_PATH }}/${{ env.UNZIPPED_RELEASE_FOLDER }}/${{ inputs.build-folder-name }}" -Destination "${{ env.SERVICE_ROOT_PATH }}/${{ inputs.build-folder-name }}" -Recurse -Force

      - name: Delete extracted release folder
        run: Remove-Item -Path "${{ env.SERVICE_ROOT_PATH }}/${{ env.UNZIPPED_RELEASE_FOLDER }}" -Recurse -Force

      - name: Overwrite env file (if it exists)
        run: if (Test-Path "${{ env.SERVICE_ROOT_PATH }}/${{ inputs.env-file-name}}")
          { Copy-Item -Path "${{ env.SERVICE_ROOT_PATH }}/${{ inputs.env-file-name}}" -Destination "${{ env.SERVICE_ROOT_PATH }}/${{ inputs.build-folder-name }}/${{ inputs.env-file-name}}" -Force }

      - name: Start Agent windows service
        run: if ((Get-Service "${{ inputs.windows-service-name }}").Status -eq "Stopped") { Start-Service -Name "${{ inputs.windows-service-name }}" }

      - name: Clean up release folder (delete all files except last 5 release folders)
        run: Get-ChildItem -Path "${{ env.SERVICE_ROOT_PATH }}/releases" | Sort-Object -Property CreationTime -Descending | Select-Object -Skip 5 | Remove-Item -Recurse -Force

    #   - name: Curl to MonitorHub to confirm version update succeeded or failed
    #     # ensure this step is executed even if the previous step fails.
    #     if: always()
    #     run: curl -X POST https://api.scout-camp.io/monitorhub
