# Download object from S3
name: download-s3

on:
  workflow_call:
    secrets:
      AWS_ROLE_TO_ASSUME:
        description: "ARN of the AWS role to assume"
        required: true

    inputs:
      runs-on:
        description: "The type of runner(s) to use (comma separated)"
        type: string
        required: true

      s3-bucket:
        description: "Name of the S3 bucket to download from"
        type: string
        required: true

      s3-prefix:
        description: "Name of the S3 bucket prefix (subfolder) to upload to"
        type: string
        required: false
        default: ""

      s3-obj-filter:
        description: "Filter for the S3 object name leave empty to get the last modified object"
        type: string
        required: false
        default: ""

      download-path:
        description: "The path to download the object to"
        type: string
        required: true

      unzip-file:
        description: "Unzip downloaded S3 object file"
        type: boolean
        required: false
        default: false

    outputs:
      downloaded-name:
        description: "The name of the downloaded file or folder (if unzipped)"
        value: ${{ jobs.download-from-s3.outputs.output1 }}

permissions:
  id-token: write # This is required for OIDC requesting the JWT

jobs:
  download-from-s3:
    runs-on: ${{ inputs.runs-on }}

    outputs:
      output1: ${{ steps.unzip-file-id.outputs.downloaded-name }}

    steps:
      # This job is not intended to run on ubuntu-latest. It downloads the s3 object on the runner's local machine for another job to use. When ununtu-latest the machine gets destroyed after the job is done.
      - name: Log runner label(s) & fail if 'ubuntu-latest'
        shell: pwsh
        run: |
          echo "runs-on: ${{ inputs.runs-on }}"
          if ("${{ inputs.runs-on }}" -eq 'ubuntu-latest') {
            echo "This workflow is not intended to run on ubuntu-latest. Please use self-hosted runner label(s)."
            exit 1
          }

      # ********** Download object from S3 **********
      - name: Configure AWS credentials
        id: configure-aws-credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: DownloadS3Object
          aws-region: eu-central-1

      - name: Get S3 object name (search by s3-obj-filter) & fail if it doesn't exists
        id: get-s3-object-name
        run: |
          # STEP 1: Get S3 object (remove bucket subfolder (prefix) from object name)
          $ObjName = (aws s3api list-objects-v2 --bucket "${{ inputs.s3-bucket }}" --prefix "${{ inputs.s3-prefix }}" --query "reverse(sort_by(Contents[?contains(Key, '${{ inputs.s3-obj-filter}}.zip')], &LastModified))[0].Key" --output text).replace("${{ inputs.s3-prefix }}/", "")
          echo "Object name in S3: $ObjName"
          # STEP 2: throw an error if $ObjName has no value
          if (!$ObjName) {
            throw "Object not found in S3. Invalid s3-obj-filter."
          }
          # STEP 3: set $ObjName as an env variable (check os to use appropriate syntax)
          if ("${{ runner.os }}" -eq 'Linux') {
              echo "obj-name=$ObjName" >> $GITHUB_OUTPUT
          }
          else {
              echo "obj-name=$ObjName" >> $env:GITHUB_OUTPUT
          }

      - name: Download object from S3 # (if object doesn't exists locally (as a directory or file))
        shell: pwsh
        # @() in an array operator - is used to force the output into an array
        run: |
          # STEP 1: Check if 'download-path' is a valid path
            if(!(Test-Path "${{ inputs.download-path }}")) {
                throw "Invalid 'download-path' input. The following path does not exist: '${{ inputs.download-path }}'."
            }

          # STEP 2: Check if S3 object already exists locally (as a directory or file)

          # STEP 2.a: Get all directories in the 'download-path' (as array) (only if 'unzip-file'=true, cause then unzipped S3 object could be a directory)
          if("${{ inputs.unzip-file }}" -eq "true") {
            $dirs = @(Get-ChildItem -Path "${{ inputs.download-path }}/" -Directory)
          }

          # STEP 2.b: Get all files (to get zipped files) in the 'download-path' (as array)
          $files = @(Get-ChildItem -Path "${{ inputs.download-path }}/" -File)

          # STEP 2.c: Concatenate the arrays & filter result by object name
          $objName = "${{ steps.get-s3-object-name.outputs.obj-name }}".replace('.zip', '')
          # filtering with or without .zip ext, in case the object got unzipped after download.
          $filtered = $dirs + $files | Where-Object { $_.Name -eq "$objName" -or $_.Name -eq "$objName.zip" }

          # STEP 2: Download the object if it doesn't exist locally
          if(!($filtered)) {
            aws s3 cp "s3://${{ inputs.s3-bucket }}/${{ inputs.s3-prefix }}/${{ steps.get-s3-object-name.outputs.obj-name }}" "${{ inputs.download-path }}/${{ steps.get-s3-object-name.outputs.obj-name }}" 
          }
          else {
            echo "Object '$objName' already exists locally. Skipping download."
          }

      - name: Unzip downloaded object file & set 'obj-name' output variable
        id: unzip-file-id
        run: |
          # STEP 1: Check if downloaded object exists and is a zip file
          $objPath = "${{ inputs.download-path }}/${{ steps.get-s3-object-name.outputs.obj-name }}"
          $objName = "${{ steps.get-s3-object-name.outputs.obj-name }}"
          if(("${{ inputs.unzip-file }}" -eq "true") -and (Test-Path "$objPath") -and (Get-Item "$objPath").Extension -eq ".zip")
          {
            # STEP 2: Unzip the object (use -Force to overwrite existing files)
            Expand-Archive -Path "$objPath" -DestinationPath "$objPath".replace(".zip", "") -Force
            # STEP 3: Remove the zip file
            Remove-Item "$objPath"
          }
          else {
            echo "Object '$objName' doesn't exist locally or is not a zip file. Skipping unzip."
          }
          # STEP 5: Remove ".zip" from the object name
          if ("${{ inputs.unzip-file }}" -eq "true") { $objName = "$objName".replace(".zip", "") }

          # STEP 6: Set $objName as an env variable (check os to use appropriate syntax)
          if ("${{ runner.os }}" -eq 'Linux') {
            echo "downloaded-name=$objName" >> $GITHUB_OUTPUT
          }
          else {
            echo "downloaded-name=$objName" >> $env:GITHUB_OUTPUT
          }
